1. 复杂度是n*n的排序
    1.1 选择排序，冒泡排序（选择排序与冒泡排序的思路类似）
            都是第一次遍历找出最大值，然后第二次排序找出次大值，以此类推到最后一个元素
            但是找出最大值的方式不同
            选择排序 是遍历 记录最大值下标的方式
            冒泡排序 是遍历 比较相邻的元素 将最大值冒泡出来的方式

            编码的难点集中在判断 内外层循环遍历的次数

    1.2 插入排序
            插入排序的思想：已知前面的k个数是已经排好序的序列，然后把后面的n-k个数插入到前面的序列中去。对于已经排好序的复杂度是n,

            循环的起始点是从第二个数开始（第一个数默认有序） 一直到最后一个数  外层循环 1 ~ n-1
            记录第k+1个数，与前面的已经排好序列的k个数 挨个交换比较。

2. 复杂度n*lgn的排序
    2.1  快速排序
            快排是个内部排序，内部排序即需要把所有的数据都读入内存中，然后整体排序。
            快排函数输入  待排序数组 array int[],int l,int r
            快排的主要思想是, 选取一个基准值base。然后把<base的放入到base的左边，大于base放入到base的右边
            再基于base的左边部分再选取一个基准值，重复上述过程，基于base的右边再选取一个基准值，重复上述过程(递归)

            快速排序的平均复杂度是n*lgn。但如果base选取的不好，可能退化为n*n

            2.1.1 快速排序的第二版优化(优化迭代)
                  单边快排优化

            2.1.2 快速排序的第三版优化(优化基准值)
                  基准值选择优化

            2.1.3 快速排序的第四版优化(优化while循环)
                  while循环改为do while优化

    2.2  归并排序
            归并排序是个外部排序，可以处理超大数据量的排序(譬如数据有20g,内存有2g,可以分为10路)
            归并函数输入  待排序数组 array int[],int l,int r
            归并排序的主要思想(2路归并排序), 将l~r 分为2部分 l~(l+r)>>1  与 (l+r)>>1+1~r 两部分，对这2部分分别进行排序，然后合并。
            然后针对l~(l+r)>>1  与 (l+r)>>1+1~r的部分重复上述过程(递归)
            大体就是先归后并，归就是将一个大数组分为n个小数组，并就是把n个小数组得结果合并起来。

